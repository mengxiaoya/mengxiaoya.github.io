<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="读书笔记,">










<meta name="description" content="Chapter 1 Java多线程技能1. 线程和进程进程是受操作系统管理的基本运行单元。 线程是在进程中独立运行的子任务。 多线程的意义：在同一时间内运行更多不同种类的任务。CPU在这些任务之间不停的切换，由于切换的速度飞快，所以给使用者的感觉就是这些任务在同时运行。 多线程是异步的，使用多线程就是在使用异步。所以在使用多线程技术时，代码的运行结果与代码执行顺序或调用顺序是无关的。 Thread">
<meta name="keywords" content="读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程编程核心技术读书笔记">
<meta property="og:url" content="http://yoursite.com/2020/06/06/Java多线程编程技术读书笔记/index.html">
<meta property="og:site_name" content="Mxsenn">
<meta property="og:description" content="Chapter 1 Java多线程技能1. 线程和进程进程是受操作系统管理的基本运行单元。 线程是在进程中独立运行的子任务。 多线程的意义：在同一时间内运行更多不同种类的任务。CPU在这些任务之间不停的切换，由于切换的速度飞快，所以给使用者的感觉就是这些任务在同时运行。 多线程是异步的，使用多线程就是在使用异步。所以在使用多线程技术时，代码的运行结果与代码执行顺序或调用顺序是无关的。 Thread">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/06/06/Java多线程编程核心技术/1.png">
<meta property="og:updated_time" content="2020-06-06T10:13:38.204Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程编程核心技术读书笔记">
<meta name="twitter:description" content="Chapter 1 Java多线程技能1. 线程和进程进程是受操作系统管理的基本运行单元。 线程是在进程中独立运行的子任务。 多线程的意义：在同一时间内运行更多不同种类的任务。CPU在这些任务之间不停的切换，由于切换的速度飞快，所以给使用者的感觉就是这些任务在同时运行。 多线程是异步的，使用多线程就是在使用异步。所以在使用多线程技术时，代码的运行结果与代码执行顺序或调用顺序是无关的。 Thread">
<meta name="twitter:image" content="http://yoursite.com/2020/06/06/Java多线程编程核心技术/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/06/Java多线程编程技术读书笔记/">





  <title>Java多线程编程核心技术读书笔记 | Mxsenn</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mxsenn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/06/Java多线程编程技术读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XYa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mxsenn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java多线程编程核心技术读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-06T18:09:28+08:00">
                2020-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/06/Java多线程编程技术读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/06/Java多线程编程技术读书笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="Chapter-1-Java多线程技能"><a href="#Chapter-1-Java多线程技能" class="headerlink" title="Chapter 1 Java多线程技能"></a>Chapter 1 Java多线程技能</h4><h5 id="1-线程和进程"><a href="#1-线程和进程" class="headerlink" title="1. 线程和进程"></a>1. 线程和进程</h5><p>进程是受操作系统管理的基本运行单元。</p>
<p>线程是在进程中独立运行的子任务。</p>
<p>多线程的意义：在同一时间内运行更多不同种类的任务。CPU在这些任务之间不停的切换，由于切换的速度飞快，所以给使用者的感觉就是这些任务在同时运行。</p>
<p><strong>多线程是异步的，使用多线程就是在使用异步。</strong>所以在使用多线程技术时，代码的运行结果与代码执行顺序或调用顺序是无关的。</p>
<p>Thread类中的start方法通知“线程规划器”此线程已准备就绪，等待调用线程对象的run方法，其实这个过程就是让系统安排一个时间来调用run方法，具有异步的效果。如果在调用时直接调用了run方法则没有异步的效果，必须等run方法中的代码执行完毕才可以执行后面的代码。</p>
<p>实现多线程的两种方式：继承Thread类，实现Runnable接口。(后者较好，因为Java中不支持多继承)</p>
<h5 id="2-使用多线程"><a href="#2-使用多线程" class="headerlink" title="2. 使用多线程"></a>2. 使用多线程</h5><ol>
<li>Thread.currentThread()和this的区别</li>
</ol>
<p>在线程不作为参数传入另一个线程时，this和Thread.currentThread()【表面上】代表的是同一个对象。而当线程作为参数传入时，this指向当前对象，即内部线程，而Thread.currentThread() 指向当前方法被哪个线程调用的那个对象，即外部线程。</p>
<ol start="2">
<li>isAlive()  sleep()  getId()方法</li>
</ol>
<h5 id="3-停止线程"><a href="#3-停止线程" class="headerlink" title="3. 停止线程"></a>3. 停止线程</h5><ol>
<li>停止线程</li>
</ol>
<p>Java中有以下三种方法可以终止正在执行的线程：</p>
<p>1）使用退出标志，线程正常退出，也就是当run方法执行完成后终止线程。</p>
<p>2）使用stop方法强制终止线程，但是不推荐使用这个方法。因为stop和suspend及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果。</p>
<p>3）使用interrupt方法中断线程。</p>
<ol start="2">
<li>interrupted() 和 isInterrupted() 方法</li>
</ol>
<p>调用interrupt()方法只是给线程设置了一个中断标记，并不是立即停止当前线程，线程仍然会继续运行。</p>
<p>这两个方法的区别：</p>
<p>区别一：</p>
<p>interrupted()：测试<strong>当前线程</strong>是否已经是中断状态，执行后具有将状态标志清除为false的功能。换句话说，如果两次调用这个方法，第一次返回true，第二次返回false，因为第一次调用完成后清除了中断状态。</p>
<p>isInterrupted()：测试<strong>线程Thread对象</strong>是否已经是中断状态，但不清除状态标志。</p>
<p>区别二：</p>
<p>interrupted()是静态方法：内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态。只能通过Thread.interrupted()来调用。</p>
<p>isInterrupted()是实例方法，是调用该方法的对象所表示的那个线程的isInterrupted()，不会重置当前线程的中断状态。</p>
<ol start="3">
<li>异常法停止线程继续向下执行</li>
</ol>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"thread already interrupted!"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"after for loop."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"InterruptedException occur!"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            thread.start();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 这句话不会打印，因为run方法已经把中断异常捕获了</span></span><br><span class="line">            System.out.println(<span class="string">"main catch!"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"main end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">268085</span></span><br><span class="line">i = <span class="number">268086</span></span><br><span class="line">i = <span class="number">268087</span></span><br><span class="line">i = <span class="number">268088</span></span><br><span class="line">i = <span class="number">268089</span></span><br><span class="line">i = <span class="number">268090</span></span><br><span class="line">thread already interrupted!</span><br><span class="line">InterruptedException occur!</span><br><span class="line">main end!</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at thread.MyThread.run(MyThread.java:<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>说明：如果没有throw new InterruptedException();这句代码，那么MyThread线程不会终止运行，会一直将for循环执行完毕，并且after for loop.这句输出也会打印。</p>
<ol start="4">
<li>sleep与interrupt</li>
</ol>
<p>如果一个正在sleep的线程又执行到了interrupt方法，会抛出java.lang.InterruptedException: sleep interrupted异常，并且清除停止状态值，使之变为false。</p>
<p>如果一个正在interrupt的线程又执行到了interrupt方法，也会抛出java.lang.InterruptedException: sleep interrupted异常，并且清除停止状态值，使之变为false。</p>
<ol start="5">
<li>stop方法</li>
</ol>
<p>使用stop方法停止线程是非常暴力的，而且会抛出java.lang.ThreadDeath，但是在通常的情况下，该异常不需要显示的捕捉。而且使用stop方法可能还会引发以下问题：</p>
<p>1）有可能使一些清理性的工作得不到完成</p>
<p>2）对锁定的对象进行了“解锁“，导致数据得不到处理，出现数据不一致的问题</p>
<p>综上来看，stop方法在功能上是有一定缺陷的，所以不建议在程序中使用该方法。</p>
<ol start="6">
<li>使用return停止线程</li>
</ol>
<p>将方法interrupt()与return结合使用也能实现停止线程的效果。就是将[3]中的[异常法停止线程继续向下执行]使用示例中的throw new InterruptedException() 修改为return。不过还是建议使用[3]中的“抛异常”的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止的事件得以传播。</p>
<h5 id="4-暂停线程"><a href="#4-暂停线程" class="headerlink" title="4. 暂停线程"></a>4. 暂停线程</h5><p>在Java中，可以使用suspend方法暂停线程，resume方法恢复线程的执行。</p>
<p>suspend和resume方法都被标记为@Deprecated，是因为它们有如下缺点：</p>
<ol>
<li>独占</li>
</ol>
<p>如果在一个持有synchronized关键字的方法A里面调用了suspend方法，则该方法会被永远“锁住”，其它线程再也不会进入到A方法中。</p>
<ol start="2">
<li>不同步</li>
</ol>
<p>使用suspend方法还可能会造成数据不同步的情况，比如做一个更新用户密码操作时，更新完用户名后执行了该方法，则密码没有更新，用户还得使用原来的密码，但是此时用户已经认为密码更新完成了。</p>
<h5 id="5-yield方法"><a href="#5-yield方法" class="headerlink" title="5. yield方法"></a>5. yield方法</h5><p>yield方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU的执行时间。但放弃的时间不确定，有可能执行yield的线程刚刚放弃，马上又获得了CPU时间片。</p>
<h5 id="6-线程的优先级"><a href="#6-线程的优先级" class="headerlink" title="6. 线程的优先级"></a>6. 线程的优先级</h5><p>CPU会优先执行优先级较高的线程对象中的任务。</p>
<p>JDK中使用了三个常量来预置定义优先级的值(在Thread类中)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>线程优先级的特性：</p>
<ol>
<li>传递性(继承性)：比如A线程启动B线程，则B线程的优先级是和A一样的。</li>
<li>规则性：CPU尽量让执行资源让给优先级比较高的线程。</li>
<li>随机性：线程的优先级与执行时打印的日志顺序无关，优先级高的线程并不一定每一次都先执行完run方法中的任务。</li>
</ol>
<h5 id="7-守护线程"><a href="#7-守护线程" class="headerlink" title="7. 守护线程"></a>7. 守护线程</h5><p>在Java中有两种线程：用户线程和守护线程。</p>
<p>当一个Java进程中不存在非守护线程了，则守护线程自动销毁。所以守护线程是一种“陪伴”的含义。典型的守护线程就是垃圾回收线程。</p>
<h4 id="Chapter-2-对象及变量的并发访问"><a href="#Chapter-2-对象及变量的并发访问" class="headerlink" title="Chapter 2 对象及变量的并发访问"></a>Chapter 2 对象及变量的并发访问</h4><p><strong>java语言支持的变量类型</strong></p>
<ul>
<li>类变量：独立于方法之外的变量，用 static 修饰。</li>
<li>局部变量：类的方法中的变量。</li>
<li>实例变量（全局变量）：独立于方法之外的变量，不过没有 static 修饰。</li>
</ul>
<h5 id="1-synchronized同步方法"><a href="#1-synchronized同步方法" class="headerlink" title="1. synchronized同步方法"></a>1. synchronized同步方法</h5><ol>
<li>方法内部的变量(局部变量)是方法私有的变量，不会存在线程安全问题。</li>
<li>实例变量是非线程安全的。</li>
<li>多线程访问多个对象时，JVM会创建多个锁。这是因为关键字synchronized取得的是对象锁，而不是把一段代码或方法当做锁。</li>
<li>只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要。</li>
</ol>
<h5 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2. 脏读"></a>2. 脏读</h5><p>在读取实例变量时，此值已经被其它线程修改过了，这种现象称为脏读。</p>
<p>脏读是通过synchronized关键字来解决的，或者通过其它同步手段解决。</p>
<ol>
<li>当线程A调用anyObject对象加入synchronized关键字的方法X时，A线程就获得了X方法所在对象的锁。所以其它线程必须等A线程执行完毕X方法才可以调用X方法，但B线程可以随意调用其它非同步方法。</li>
<li>当线程A调用anyObject对象加入synchronized关键字的方法X时，A线程就获得了X方法所在对象的锁。而B线程如果调用声明了synchronized关键字的非X方法，也必须等A线程将X方法执行完，也就是释放了对象锁之后才可以调用。</li>
</ol>
<h5 id="3-synchronized是一种可重入锁"><a href="#3-synchronized是一种可重入锁" class="headerlink" title="3. synchronized是一种可重入锁"></a>3. synchronized是一种可重入锁</h5><ol>
<li>可重入锁概念：自己可以再次获取自己的内部锁。比如有一个A线程获取了某个对象的锁，在A线程没有释放此对象锁之前，当其再次想要获取这个对象的锁的时候还是可以获取的。如果不可重入的话，就会造成死锁。</li>
<li>当<strong>出现异常时，synchronized锁会自动释放</strong>。</li>
<li>同步不具有继承性。即：假如B继承A，A中有一个synchronized的a方法，子类B中重写了这个a方法，但B中的a方法也必须添加synchronized才可以实现同步。</li>
</ol>
<h5 id="4-synchronized同步语句块"><a href="#4-synchronized同步语句块" class="headerlink" title="4. synchronized同步语句块"></a>4. synchronized同步语句块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"> 	 <span class="comment">// code</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步代码块存在的意义就是提醒程序员<strong>将该加同步的代码最细化</strong>。尽量不要将synchronized整个加在某一个方法上面，因为这样效率会很低。</p>
<p>和synchronized一样，synchronized(this)同步代码块也是锁定当前对象的。</p>
<h5 id="5-Java中支持将任意对象作为对象监听器"><a href="#5-Java中支持将任意对象作为对象监听器" class="headerlink" title="5. Java中支持将任意对象作为对象监听器"></a>5. Java中支持将任意对象作为对象监听器</h5><p>锁非this对象具有一定的优点：如果一个类中有很多个synchronized方法，这时虽然能实现同步，但是会受到阻塞，所以影响运行效率；如果此时使用同步代码块锁非this对象，则synchronized(非this)代码块中的程序和同步方法(同步方法其实就是synchronized(this))是异步的，不与同步方法争抢this锁，可以大大提高程序运行效率。</p>
<h5 id="6-静态同步方法"><a href="#6-静态同步方法" class="headerlink" title="6. 静态同步方法"></a>6. 静态同步方法</h5><p>synchronized加到static静态方法上是给Class类上锁，而synchronized加到非静态方法上是给对象上锁。</p>
<p>Class锁对当前的*.java文件对应的Class类进行持锁，对这个类的所有实例对象起作用。而对象锁只对自己的实例对象起作用。</p>
<h5 id="7-数据类型String的常量池特性"><a href="#7-数据类型String的常量池特性" class="headerlink" title="7. 数据类型String的常量池特性"></a>7. 数据类型String的常量池特性</h5><p>大多数情况下，同步代码块都不会使用String对象作为锁对象，而改用其它，比如new Object()实例化一个Object对象，因为它并不放入缓存中。</p>
<h5 id="8-多线程的死锁"><a href="#8-多线程的死锁" class="headerlink" title="8. 多线程的死锁"></a>8. 多线程的死锁</h5><p>死锁是一个经典的多线程问题，因为不同的线程都在等待根本不可能释放的锁，从而导致所有的任务都无法继续完成。在多线程中，“死锁”是必须避免的，因为这样会造成程序的“假死”。</p>
<p>使用JDK自带工具检测是否有死锁：</p>
<p>jstack -l pid</p>
<p>如果有死锁会有Found 1 deadlock字样。</p>
<p>如下是一个死锁代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"a"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"username = "</span> + username);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"lock1 -&gt; lock2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"b"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"username = "</span> + username);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"lock2 -&gt; lock1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DeadLockDemo thread = <span class="keyword">new</span> DeadLockDemo();</span><br><span class="line">            thread.setUsername(<span class="string">"a"</span>);</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">            t1.start();</span><br><span class="line"></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            thread.setUsername(<span class="string">"b"</span>);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="9-锁对象"><a href="#9-锁对象" class="headerlink" title="9. 锁对象"></a>9. 锁对象</h5><p>在将任何数据类型作为同步锁时，需要注意的是，是否有多个线程同时持有锁对象，如果同时持有相同的锁对象，则这些线程之间就是同步的；如果分别获得锁对象，这些线程之间就是异步的。</p>
<h5 id="10-volatile与synchronized的区别"><a href="#10-volatile与synchronized的区别" class="headerlink" title="10. volatile与synchronized的区别"></a>10. volatile与synchronized的区别</h5><ol>
<li>volatile是线程同步的轻量级实现，所以性能肯定要比synchronized好，并且volatile只能修饰变量，而synchronized可以修饰代码块和方法。随着JDK新版本的发布，synchronized在执行效率上得到了很大的提升，在开发中使用该关键字的概率还是比较大的。</li>
<li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。</li>
<li>volatile可以保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。</li>
<li>synchronized同步代码块包含volatile同步的功能。</li>
</ol>
<p><strong>线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。</strong></p>
<p>volatile非线程安全的原因是因为变量在内存中的工作过程如下：</p>
<ol>
<li>read和load阶段：从主内存复制变量到当前工作内存；</li>
<li>use和assign阶段：执行代码，改变共享变量的值；</li>
<li>store和write阶段：用工作内存数据刷新主内存对应变量的值。</li>
</ol>
<p>使用<strong>原子类</strong>进行多线程下的i++操作。</p>
<h4 id="Chapter-3-线程间通信"><a href="#Chapter-3-线程间通信" class="headerlink" title="Chapter 3 线程间通信"></a>Chapter 3 线程间通信</h4><h5 id="1-不使用等待-通知机制实现线程间通信"><a href="#1-不使用等待-通知机制实现线程间通信" class="headerlink" title="1. 不使用等待/通知机制实现线程间通信"></a>1. 不使用等待/通知机制实现线程间通信</h5><p>方法是通过while语句轮询机制来检测某一个条件，这样会浪费CPU资源。</p>
<h5 id="2-等待-通知机制的实现"><a href="#2-等待-通知机制的实现" class="headerlink" title="2. 等待/通知机制的实现"></a>2. 等待/通知机制的实现</h5><p>什么是等待/通知机制？</p>
<p>服务员和厨师的例子：厨师没有做完菜之前，服务员一直处于等待的状态。厨师做完菜后将菜放在“菜品传递柜”上，其实就相当于一种通知，这样服务员才可以拿到菜品并交给就餐者。</p>
<p><strong>wait和notify方法介绍</strong></p>
<p>wait和notify还有notifyAll都是Object类的方法。</p>
<ol>
<li><p>wait()：在调用wait之前，线程必须获得该对象的对象级别锁，即只能在同步方法或者同步代码块中调用wait方法。在执行wait方法之后，当前线程释放锁。</p>
<p>如果调用wait方法时没有持有适当的锁，则会抛出IllegalMonitorStateExeception，它是RuntimeException的一个子类，因此不需要try-catch。</p>
</li>
<li><p>notify()：在调用notify之前，线程必也须获得该对象的对象级别锁，即只能在同步方法或者同步代码块中调用notify方法。在执行notify方法之后，由线程规划器从所有wait这个对象锁的线程中随机挑选出一个，对其发出notify通知，并使它等待获取该对象的对象锁。</p>
<p>如果调用notify方法时没有持有适当的锁，也会抛出IllegalMonitorStateExeception，它是RuntimeException的一个子类，因此不需要try-catch。</p>
<p>需要说明的时，<strong>在执行notify方法后，当前线程不会马上释放该对象锁</strong>，呈wait状态的线程也并不能马上获取该对象锁，<strong>要等到执行notify方法的线程将程序执行完，也就是退出synchronized代码块之后，当前线程才释放锁。</strong></p>
<p>当第一个获得了该对象锁的wait线程执行完毕后，它会释放掉对象锁。但此时如果该对象没有再次使用notify语句，即便该对象已经空闲，其它wait线程由于错过了第一次的notify通知还是会继续阻塞在wait状态，直到这个对象发出一个notify或者notifyAll。</p>
</li>
</ol>
<h5 id="3-wait-notify-notifyAll方法说明"><a href="#3-wait-notify-notifyAll方法说明" class="headerlink" title="3. wait notify notifyAll方法说明"></a>3. wait notify notifyAll方法说明</h5><p>wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。</p>
<p>notify()方法可以随机唤醒等待队列中等待同一个共享资源的“一个”线程，并使该线程退出等待队列，进入可运行状态，也就是notify仅通知“一个”线程。可以在代码中多次调用notify唤醒多个，调用几次就唤醒几个。</p>
<p>notifyAll()方法可以使所有正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，线程优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM的状态。</p>
<h5 id="4-线程状态切换示意图"><a href="#4-线程状态切换示意图" class="headerlink" title="4. 线程状态切换示意图"></a>4. 线程状态切换示意图</h5><p><img src="/2020/06/06/Java多线程编程技术读书笔记/../Java多线程编程核心技术\1.png" alt="avatar"></p>
<p>每个锁对象都有两个队列，一个是<strong>就绪队列</strong>，一个是<strong>阻塞队列</strong>。就绪队列存储了将要获得锁的线程，阻塞队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等到CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。</p>
<h5 id="5-当interrupt方法遇到wait方法"><a href="#5-当interrupt方法遇到wait方法" class="headerlink" title="5. 当interrupt方法遇到wait方法"></a>5. 当interrupt方法遇到wait方法</h5><p>线程呈wait状态时，调用线程对象的interrupt方法会出现InterruptedException异常。</p>
<h5 id="6-wait-long"><a href="#6-wait-long" class="headerlink" title="6. wait(long)"></a>6. wait(long)</h5><p>wait(long)方法的功能是等待某一段时间内是否有线程对锁进行唤醒，如果没有则超过这个时间自动唤醒。</p>
<h5 id="7-使用等待-通知时的注意事项"><a href="#7-使用等待-通知时的注意事项" class="headerlink" title="7. 使用等待/通知时的注意事项"></a>7. 使用等待/通知时的注意事项</h5><ol>
<li>假如在使用wait和notify时，还没有线程执行wait，某个线程就执行了notify，就是通知过早。此时会造成再执行wait的线程一直在wait，还在等待notify呢。</li>
<li>在使用wait/notify时，还要注意一种情况。假如有两个线程呈wait状态，wait之后的操作是对一个List进行remove(0)操作，当List中只有一个元素时，此时其它持有同一个对象锁的线程执行了notifyAll，则两个wait状态的线程只有一个可以remove成功，另一个出现索引溢出的异常。解决此问题的办法是remove时先判断一下有没有元素，这也是自己写代码时的一个习惯问题。</li>
</ol>
<h5 id="8-生产者-消费者模式实现"><a href="#8-生产者-消费者模式实现" class="headerlink" title="8. 生产者/消费者模式实现"></a>8. 生产者/消费者模式实现</h5><p>使用wait/notify实现生产者/消费者模式的思路：</p>
<p>目标是向一个List中存取元素，List的大小是1。生产者线程要有while true判断当前list大小，如果是1，则wait；否则put一个元素并notify。消费者线程要有while true判断当前list大小，如果是0，则wait；否则get并remove一个元素并notify。时刻保证List的大小不会超过1。</p>
<p>单生产单消费、单生产多消费、多生产单消费、多生产多消费</p>
<h5 id="9-通过管道进行线程间的通信"><a href="#9-通过管道进行线程间的通信" class="headerlink" title="9. 通过管道进行线程间的通信"></a>9. 通过管道进行线程间的通信</h5><p>字节流：PipedInputStream、PipedOutputStream</p>
<p>字符流：PipedReader、PipedWriter</p>
<h5 id="10-使用等待-通知机制实现交叉备份"><a href="#10-使用等待-通知机制实现交叉备份" class="headerlink" title="10. 使用等待/通知机制实现交叉备份"></a>10. 使用等待/通知机制实现交叉备份</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbTools</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> prevIsA = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">backupA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (prevIsA) &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"AAAAA"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prevIsA = <span class="keyword">true</span>;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">backupB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!prevIsA) &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"BBBBB"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prevIsA = <span class="keyword">false</span>;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackupA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DbTools dbTools;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BackupA</span><span class="params">(DbTools dbTools)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.dbTools = dbTools;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dbTools.backupA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackupB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DbTools dbTools;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BackupB</span><span class="params">(DbTools dbTools)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.dbTools = dbTools;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dbTools.backupB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DbTools dbTools = <span class="keyword">new</span> DbTools();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            BackupA backupA = <span class="keyword">new</span> BackupA(dbTools);</span><br><span class="line">            backupA.start();</span><br><span class="line"></span><br><span class="line">            BackupB backupB = <span class="keyword">new</span> BackupB(dbTools);</span><br><span class="line">            backupB.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="11-join方法的使用"><a href="#11-join方法的使用" class="headerlink" title="11. join方法的使用"></a>11. join方法的使用</h5><p>join方法的作用：使所属的线程对象x正常执行run方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码。</p>
<p>方法join具有使线程排队的作用，有些类似同步的运行效果。join与synchronized的区别是：在join内部使用wait方法进行等待，而synchronized关键字使用的是“对象监视器”原理作为同步。</p>
<p>当join方法遇到interrupt方法时，会抛出InterruptedException异常。</p>
<p>join(long)方法：参数设定的是等待的时间。</p>
<h5 id="12-join-long-和sleep-long-的区别"><a href="#12-join-long-和sleep-long-的区别" class="headerlink" title="12. join(long)和sleep(long)的区别"></a>12. join(long)和sleep(long)的区别</h5><p>由于join内部实现是使用的wait方法，所以join具有释放锁的特点，当前执行join方法的线程的锁被释放，那么其他线程就可以调用此线程中的同步方法了。</p>
<p>Thread.sleep(long)方法只是等待，没有释放锁的特点。</p>
<h5 id="13-ThreadLocal类的使用"><a href="#13-ThreadLocal类的使用" class="headerlink" title="13. ThreadLocal类的使用"></a>13. ThreadLocal类的使用</h5><p>当所有的线程都需要共享一个变量时，可以使用public static变量的形式。</p>
<p>但如果每个线程都想拥有一个自己的共享变量呢？就可以用ThreadLocal来实现。</p>
<p>ThreadLocal类的作用：ThreadLocal变量用来存储每个线程自己的共享变量。可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>此类解决的就是<strong>变量在不同线程间的隔离性</strong>，也就是不同线程拥有自己的值，不同线程的值是可以放入ThreadLocal类中来进行保存的。</p>
<p><strong>ThreadLocal的使用：</strong></p>
<ol>
<li>如果只是new一个ThreadLocal变量，那么第一次get获取值的时候是null，给ThreadLocal变量赋默认值的方法为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; stringThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"defaultValue"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者用withInitial()方法加lambda表达式简写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; stringThreadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">"defaultValue"</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>主线程为main，主线程下有10个子线程，则只需要在主线程中定义一个ThreadLocal变量即可，这样10个子线程各自的变量值之间就是相互隔离的，各自用各自的，不用每个子线程都定义一个ThreadLocal变量。</li>
</ol>
<h5 id="14-拓展：InheritableThreadLocal"><a href="#14-拓展：InheritableThreadLocal" class="headerlink" title="14. 拓展：InheritableThreadLocal"></a>14. 拓展：InheritableThreadLocal</h5><p>使用此类可以让子线程取得父线程继承下来的值。取得之后还可以对值进行进一步的处理。</p>
<p>但需要注意的一点是：在子线程继承到父线程的值之后，若父线程对值进行了更改，子线程是接收不到这个讯息的，使用的还是第一次继承得到的值。</p>
<h4 id="Chapter-4-Lock的使用"><a href="#Chapter-4-Lock的使用" class="headerlink" title="Chapter 4 Lock的使用"></a>Chapter 4 Lock的使用</h4><h5 id="1-ReentrantLock的使用"><a href="#1-ReentrantLock的使用" class="headerlink" title="1. ReentrantLock的使用"></a>1. ReentrantLock的使用</h5><ol>
<li>使用ReentrantLock可以实现和synchronized同样的效果，调用lock方法的线程就持有了“对象监视器”，其它线程只有等待锁被释放时才可以再次争抢。</li>
<li>使用Condition实现等待/通知机制</li>
</ol>
<p>使用notify/notifyAll方法进行通知时，被通知的线程是由JVM随机选择的。使用ReentrantLock结合Condition是可以实现“选择性通知”的。也就是说一个Lock对象里面可以创建多个Condition(即对象监视器)实例，线程对象可以在注册在指定的Condition中，从而可以<strong>有选择性的进行线程通知，在调度线程上更灵活</strong>。</p>
<p>而synchronized就相当于整个Lock对象只有一个单一的Condition，所有的线程都注册在它一个对象的身上，线程开始notify或者notifyAll时，没有选择权，只能是随机。</p>
<p>Object类中的wait()方法相当于Condition类中的await()方法。</p>
<p>Object类中的wait(long timeout)方法相当于Condition类中的await(long timeout, TimeUnit unit)方法。</p>
<p>Object类中的notify()方法相当于Condition类中的signal()方法。</p>
<p>Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。</p>
<p>使用一个Condition对象来实现等待/通知机制示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"await time: "</span> + System.currentTimeMillis());</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"signal time: "</span> + System.currentTimeMillis());</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyService myService = <span class="keyword">new</span> MyService();</span><br><span class="line">        ThreadA threadA = <span class="keyword">new</span> ThreadA(myService);</span><br><span class="line">        threadA.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        myService.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>几个示例</li>
</ol>
<p>一个Condition实现等待/通知机制  – 示例如上</p>
<p>多个Condition实现通知部分线程</p>
<p>生产者/消费者模式：一对一交替打印</p>
<p>生产者/消费者模式：多对多交替打印</p>
<ol start="4">
<li>公平锁与非公平锁</li>
</ol>
<p>使用ReentrantLock可以实现公平锁和非公平锁。使用方式为初始化锁时构造函数传入的参数true为公平锁，false或者不传(默认)为非公平锁。</p>
<p>公平锁：线程获取锁的顺序是按照线程加锁的顺序来分配的，即FIFO。</p>
<p>非公平锁：一种获取锁的抢占机制，是随机获取锁的，这种方式可能造成某些线程一直拿不到锁，所以就是非公平。</p>
<ol start="5">
<li>getHoldCount()、getQueueLength()、getWaitQueueLength()方法说明</li>
</ol>
<p>int getHoldCount()：查询当前线程保持此锁定的个数，也就是调用lock方法的次数。</p>
<p>int getQueueLength()：返回正等待获取此锁定的线程估计数，比如有5个线程，1个线程首先执行await方法，那么调用getQueueLength()方法后返回值是4，说明有4个线程在等待lock的释放。</p>
<p>int getWaitQueueLength(Condition condition)：返回等待与此锁定相关的给定条件condition的线程估计数，比如有5个线程，每个线程都执行了同一个condition的await方法，则返回值为5。</p>
<ol start="6">
<li>hasQueueThread()、hasQueueThreads()、hasWaiters()方法说明</li>
</ol>
<p>boolean hasQueueThread(Thread thread)：查询指定的线程是否在等待获取此锁定。</p>
<p>boolean  hasQueueThreads()：查询是否有线程正在等待获取此锁定。</p>
<p>boolean hasWaiters(Condition condition)：查询是否有线程正在等待与此锁定有关的condition条件。</p>
<ol start="7">
<li>isFair()、isHeldByCurrentThread()、isLocked()方法说明</li>
</ol>
<p>boolean isFair()：判断是不是公平锁。</p>
<p>boolean isHeldByCurrentThread()：查询当前线程是否保持此锁定。</p>
<p>boolean isLocked()：查询此锁定是否有线程在保持。</p>
<ol start="8">
<li>lockInterruptibly()、tryLock()、tryLock(long timeout, TimeUnit unit)方法说明</li>
</ol>
<p>void lockInterruptibly()：如果当前线程未被中断，则获取锁定；如果已中断则抛出异常。</p>
<p>boolean tryLock()：仅在调用时锁定未被另一个线程保持的情况下，才获取该锁定。</p>
<p>boolean tryLock(long timeout, TimeUnit unit)：如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未中断，则获取该锁定。</p>
<ol start="9">
<li>awaitUninterruptibly()、awaitUntil()方法说明</li>
</ol>
<p>awaitUninterruptibly()：</p>
<p>线程在调用condition.await()后处于await状态，此时调用thread.interrupt()会抛出中断异常。<br>但是使用condition.awaitUninterruptibly()后，调用thread.interrupt()则不会报错。</p>
<p>awaitUntil(Date deadline)：</p>
<p>调用此方法的线程在等待时间deadline到来之前可以被其他线程提前唤醒，否则等时间到了自动唤醒。意思就是调用这个方法的线程等一段时间后假如没有唤醒它的线程，则自动唤醒。</p>
<ol start="10">
<li>使用condition可以实现对线程执行的业务进行排序规划</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Condition conditionA = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Condition conditionB = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Condition conditionC = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> nextPrintWho = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">while</span> (nextPrintWho != <span class="number">1</span>) &#123;</span><br><span class="line">                        conditionA.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ThreadA "</span> + (i + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = <span class="number">2</span>;</span><br><span class="line">                    conditionB.signalAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">while</span> (nextPrintWho != <span class="number">2</span>) &#123;</span><br><span class="line">                        conditionB.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ThreadB "</span> + (i + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = <span class="number">3</span>;</span><br><span class="line">                    conditionC.signalAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">while</span> (nextPrintWho != <span class="number">3</span>) &#123;</span><br><span class="line">                        conditionC.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ThreadC "</span> + (i + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = <span class="number">1</span>;</span><br><span class="line">                    conditionA.signalAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread[] aArray = <span class="keyword">new</span> Thread[<span class="number">5</span>];</span><br><span class="line">        Thread[] bArray = <span class="keyword">new</span> Thread[<span class="number">5</span>];</span><br><span class="line">        Thread[] cArray = <span class="keyword">new</span> Thread[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            aArray[i] = <span class="keyword">new</span> Thread(threadA);</span><br><span class="line">            bArray[i] = <span class="keyword">new</span> Thread(threadB);</span><br><span class="line">            cArray[i] = <span class="keyword">new</span> Thread(threadC);</span><br><span class="line"></span><br><span class="line">            aArray[i].start();</span><br><span class="line">            bArray[i].start();</span><br><span class="line">            cArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ThreadA <span class="number">1</span></span><br><span class="line">ThreadA <span class="number">2</span></span><br><span class="line">ThreadA <span class="number">3</span></span><br><span class="line">ThreadB <span class="number">1</span></span><br><span class="line">ThreadB <span class="number">2</span></span><br><span class="line">ThreadB <span class="number">3</span></span><br><span class="line">ThreadC <span class="number">1</span></span><br><span class="line">ThreadC <span class="number">2</span></span><br><span class="line">ThreadC <span class="number">3</span></span><br><span class="line">ThreadA <span class="number">1</span></span><br><span class="line">ThreadA <span class="number">2</span></span><br><span class="line">ThreadA <span class="number">3</span></span><br><span class="line">ThreadB <span class="number">1</span></span><br><span class="line">ThreadB <span class="number">2</span></span><br><span class="line">ThreadB <span class="number">3</span></span><br><span class="line">ThreadC <span class="number">1</span></span><br><span class="line">ThreadC <span class="number">2</span></span><br><span class="line">ThreadC <span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="2-ReentrantReadWriteLock的使用"><a href="#2-ReentrantReadWriteLock的使用" class="headerlink" title="2. ReentrantReadWriteLock的使用"></a>2. ReentrantReadWriteLock的使用</h5><p>读写锁：读操作相关的锁，也成为共享锁；写操作相关的锁，也叫排他锁。也就是说<strong>读读之间不互斥，读与写互斥，写与写之间也互斥</strong>。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。</p>
<p><strong>总结</strong></p>
<p>完全可以使用Lock对象将synchronized关键字替换掉，而且Lock对象的功能更加丰富一些。掌握Lock有助于学习并发包中源码的实现原理，在并发包中大量的类使用了Lock接口作为同步的处理方式。</p>
<h4 id="Chapter-5-定时器Timer"><a href="#Chapter-5-定时器Timer" class="headerlink" title="Chapter 5 定时器Timer"></a>Chapter 5 定时器Timer</h4><ol>
<li>Timer的缺陷</li>
</ol>
<p>Timer计时器可以定时（指定时间执行任务）、延迟（延迟5秒执行任务）、周期性地执行任务（每隔个1秒执行任务），但是，Timer存在一些缺陷。</p>
<p>1.首先Timer对调度的支持是基于绝对时间的，而不是相对时间，所以它对系统时间的改变非常敏感。</p>
<p>2.其次Timer线程是不会捕获异常的，如果TimerTask抛出的了未检查异常则会导致Timer线程终止，同时Timer也不会重新恢复线程的执行，他会错误的认为整个Timer线程都会取消。同时，已经被安排单尚未执行的TimerTask也不会再执行了，新的任务也不能被调度。故如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。</p>
<ol start="2">
<li>使用ScheduledThreadPoolExecutor代替Timer</li>
</ol>
<p>Timer是基于绝对时间的，对系统时间比较敏感，而ScheduledThreadPoolExecutor 则是基于相对时间；Timer是内部是单一线程，而ScheduledThreadPoolExecutor内部是个线程池，所以可以支持多个任务并发执行。</p>
<p>Timer是JDK1.5出现的，因此JDK1.5之后几乎没有理由再使用Timer了，而是使用ScheduledThreadPoolExecutor来代替。</p>
<h4 id="Chapter-6-单例模式与多线程"><a href="#Chapter-6-单例模式与多线程" class="headerlink" title="Chapter 6 单例模式与多线程"></a>Chapter 6 单例模式与多线程</h4><p>本章目的：如何使单例模式遇到多线程时是安全的、正确的。</p>
<h5 id="1-单例模式的实现方式"><a href="#1-单例模式的实现方式" class="headerlink" title="1. 单例模式的实现方式"></a>1. 单例模式的实现方式</h5><ol>
<li>“饿汉”模式</li>
<li>DCL双检锁“懒汉”模式</li>
<li>使用静态内部类实现单例</li>
<li>序列化和反序列化的单例实现</li>
</ol>
<p>静态内部类可以实现单例模式，但是当反序列化时，反序列化出来的还是多例的，解决办法是在反序列化的对象类中添加readResolve()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObjectHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MyObject OBJECT = <span class="keyword">new</span> MyObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyObjectHandler.OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyObjectHandler.OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用静态代码块实现单例</li>
<li>使用枚举类实现单例</li>
</ol>
<h4 id="Chapter-7-拾遗增补"><a href="#Chapter-7-拾遗增补" class="headerlink" title="Chapter 7  拾遗增补"></a>Chapter 7  拾遗增补</h4><h5 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1. 线程的状态"></a>1. 线程的状态</h5><p>线程的状态信息存在于Thread.State枚举类中，有以下六个状态：</p>
<p>NEW：线程实例化后还未执行start()方法时的状态。</p>
<p>RUNNABLE：正在JVM中执行的线程处于这种状态。</p>
<p>BLOCKED：受阻塞并等待某个监视器锁的线程处于这种状态。</p>
<p>WAITING：线程执行了Object.wait()方法后处于这种状态。</p>
<p>TIMED_WAITING：执行了sleep方法后处于这种状态。</p>
<p>TERMINATED：线程被销毁时处于这种状态。</p>
<h5 id="2-线程组"><a href="#2-线程组" class="headerlink" title="2. 线程组"></a>2. 线程组</h5><ol>
<li>线程组的作用：批量管理线程或线程组对象，有效地对线程或线程组对象进行组织。线程组中可以有线程对象，也可以有线程组。</li>
<li>线程组的自动归属特性：在实例化一个ThreadGroup线程组x时如果不指定所属的线程组，则x线程组自动归到当前线程对象所属的线程组中，也就是隐式地在一个线程组中添加了一个子线程组。</li>
<li>JVM的根线程组：JVM的根线程组是system，再取其父线程组则出现空异常。</li>
<li>线程组内的线程批量停止：通过将线程添加到线程组中，当调用线程组ThreadGroup的interrupt()方法时，可以将该组中所有正在运行的线程批量停止。</li>
<li>递归与非递归获取线程组内对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line">ThreadGroup[] listGroupA = <span class="keyword">new</span> ThreadGroup[Thread.currentThread().getThreadGroup().activeGroupCount()];</span><br><span class="line">Thread.currentThread().getThreadGroup().enumerate(listGroupA, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">for</span> (ThreadGroup threadGroup : listGroupA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (threadGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(threadGroup.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line">ThreadGroup[] listGroupB = <span class="keyword">new</span> ThreadGroup[Thread.currentThread().getThreadGroup().activeGroupCount()];</span><br><span class="line">Thread.currentThread().getThreadGroup().enumerate(listGroupB, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (ThreadGroup threadGroup : listGroupB) &#123;</span><br><span class="line">    <span class="keyword">if</span> (threadGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(threadGroup.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-使线程具有有序性"><a href="#3-使线程具有有序性" class="headerlink" title="3. 使线程具有有序性"></a>3. 使线程具有有序性</h5><p>正常情况下，线程在运行时多个线程之间执行任务的时机是无序的，可以通过改造代码使它们的运行具有有序性。</p>
<h5 id="4-SimpleDateFormat非线程安全"><a href="#4-SimpleDateFormat非线程安全" class="headerlink" title="4. SimpleDateFormat非线程安全"></a>4. SimpleDateFormat非线程安全</h5><p>可以使用JDK8中的DateTimeFormatter 代替 SimpleDateFormat，或者使用common-lang3包的DateFormatUtils.format()，线程安全，底层基于FastDateFormat实现的。</p>
<h5 id="5-线程中出现异常的处理方式"><a href="#5-线程中出现异常的处理方式" class="headerlink" title="5. 线程中出现异常的处理方式"></a>5. 线程中出现异常的处理方式</h5><p>Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler eh)：给<strong>指定线程对象</strong>设置异常处理器。Thread.setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)：给<strong>指定线程类的所有线程对象</strong>设置默认的异常处理器。</p>
<h5 id="6-线程组中出现异常的处理方式"><a href="#6-线程组中出现异常的处理方式" class="headerlink" title="6. 线程组中出现异常的处理方式"></a>6. 线程组中出现异常的处理方式</h5><p>默认情况下，一个线程组内的某个线程发生异常后并不影响组内的其它线程正常运行，但如果想要一个组内只要有一个线程出现异常则组内所有线程全部停止，则需要如下这么做：</p>
<p>自定义一个线程组，实现uncaughtException()方法，并加this.interrupt();这句代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadGroup</span> <span class="keyword">extends</span> <span class="title">ThreadGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.uncaughtException(t, e);</span><br><span class="line">        <span class="keyword">this</span>.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="XYa 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="XYa 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/12/red-black-tree/" rel="next" title="红黑树的结构和优势">
                <i class="fa fa-chevron-left"></i> 红黑树的结构和优势
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  <div>
    
    ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------本文结束 感谢您的阅读------</div>
    
</div>
    
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">XYa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5834471410/home?leftnav=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhangqi@bonree.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Chapter-1-Java多线程技能"><span class="nav-number">1.</span> <span class="nav-text">Chapter 1 Java多线程技能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-线程和进程"><span class="nav-number">1.1.</span> <span class="nav-text">1. 线程和进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-使用多线程"><span class="nav-number">1.2.</span> <span class="nav-text">2. 使用多线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-停止线程"><span class="nav-number">1.3.</span> <span class="nav-text">3. 停止线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-暂停线程"><span class="nav-number">1.4.</span> <span class="nav-text">4. 暂停线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-yield方法"><span class="nav-number">1.5.</span> <span class="nav-text">5. yield方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-线程的优先级"><span class="nav-number">1.6.</span> <span class="nav-text">6. 线程的优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-守护线程"><span class="nav-number">1.7.</span> <span class="nav-text">7. 守护线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chapter-2-对象及变量的并发访问"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2 对象及变量的并发访问</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-synchronized同步方法"><span class="nav-number">2.1.</span> <span class="nav-text">1. synchronized同步方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-脏读"><span class="nav-number">2.2.</span> <span class="nav-text">2. 脏读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-synchronized是一种可重入锁"><span class="nav-number">2.3.</span> <span class="nav-text">3. synchronized是一种可重入锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-synchronized同步语句块"><span class="nav-number">2.4.</span> <span class="nav-text">4. synchronized同步语句块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Java中支持将任意对象作为对象监听器"><span class="nav-number">2.5.</span> <span class="nav-text">5. Java中支持将任意对象作为对象监听器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-静态同步方法"><span class="nav-number">2.6.</span> <span class="nav-text">6. 静态同步方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-数据类型String的常量池特性"><span class="nav-number">2.7.</span> <span class="nav-text">7. 数据类型String的常量池特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-多线程的死锁"><span class="nav-number">2.8.</span> <span class="nav-text">8. 多线程的死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-锁对象"><span class="nav-number">2.9.</span> <span class="nav-text">9. 锁对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-volatile与synchronized的区别"><span class="nav-number">2.10.</span> <span class="nav-text">10. volatile与synchronized的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chapter-3-线程间通信"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3 线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-不使用等待-通知机制实现线程间通信"><span class="nav-number">3.1.</span> <span class="nav-text">1. 不使用等待/通知机制实现线程间通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-等待-通知机制的实现"><span class="nav-number">3.2.</span> <span class="nav-text">2. 等待/通知机制的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-wait-notify-notifyAll方法说明"><span class="nav-number">3.3.</span> <span class="nav-text">3. wait notify notifyAll方法说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-线程状态切换示意图"><span class="nav-number">3.4.</span> <span class="nav-text">4. 线程状态切换示意图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-当interrupt方法遇到wait方法"><span class="nav-number">3.5.</span> <span class="nav-text">5. 当interrupt方法遇到wait方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-wait-long"><span class="nav-number">3.6.</span> <span class="nav-text">6. wait(long)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-使用等待-通知时的注意事项"><span class="nav-number">3.7.</span> <span class="nav-text">7. 使用等待/通知时的注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-生产者-消费者模式实现"><span class="nav-number">3.8.</span> <span class="nav-text">8. 生产者/消费者模式实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-通过管道进行线程间的通信"><span class="nav-number">3.9.</span> <span class="nav-text">9. 通过管道进行线程间的通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-使用等待-通知机制实现交叉备份"><span class="nav-number">3.10.</span> <span class="nav-text">10. 使用等待/通知机制实现交叉备份</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-join方法的使用"><span class="nav-number">3.11.</span> <span class="nav-text">11. join方法的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-join-long-和sleep-long-的区别"><span class="nav-number">3.12.</span> <span class="nav-text">12. join(long)和sleep(long)的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-ThreadLocal类的使用"><span class="nav-number">3.13.</span> <span class="nav-text">13. ThreadLocal类的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-拓展：InheritableThreadLocal"><span class="nav-number">3.14.</span> <span class="nav-text">14. 拓展：InheritableThreadLocal</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chapter-4-Lock的使用"><span class="nav-number">4.</span> <span class="nav-text">Chapter 4 Lock的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-ReentrantLock的使用"><span class="nav-number">4.1.</span> <span class="nav-text">1. ReentrantLock的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ReentrantReadWriteLock的使用"><span class="nav-number">4.2.</span> <span class="nav-text">2. ReentrantReadWriteLock的使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chapter-5-定时器Timer"><span class="nav-number">5.</span> <span class="nav-text">Chapter 5 定时器Timer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chapter-6-单例模式与多线程"><span class="nav-number">6.</span> <span class="nav-text">Chapter 6 单例模式与多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-单例模式的实现方式"><span class="nav-number">6.1.</span> <span class="nav-text">1. 单例模式的实现方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chapter-7-拾遗增补"><span class="nav-number">7.</span> <span class="nav-text">Chapter 7  拾遗增补</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-线程的状态"><span class="nav-number">7.1.</span> <span class="nav-text">1. 线程的状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-线程组"><span class="nav-number">7.2.</span> <span class="nav-text">2. 线程组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-使线程具有有序性"><span class="nav-number">7.3.</span> <span class="nav-text">3. 使线程具有有序性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-SimpleDateFormat非线程安全"><span class="nav-number">7.4.</span> <span class="nav-text">4. SimpleDateFormat非线程安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-线程中出现异常的处理方式"><span class="nav-number">7.5.</span> <span class="nav-text">5. 线程中出现异常的处理方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-线程组中出现异常的处理方式"><span class="nav-number">7.6.</span> <span class="nav-text">6. 线程组中出现异常的处理方式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XYa</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://mengxiaoya.github.io/">XYa</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'rE7gfWCMUvlTFBrVr6SUjmBU-gzGzoHsz',
        appKey: 'gTnDI7iJeAMFzajrD7wrdH70',
        placeholder: 'Thanks for reading and leave your comments.',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
